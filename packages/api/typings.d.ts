/* eslint-disable @typescript-eslint/no-unused-vars */

type _Response = Response;

declare namespace Koine.Api {
  // @see https://stackoverflow.com/a/60702896/1938970
  // import { Exact } from "type-fest";

  //////////////////////////////////////////////////////////////////////////////
  //
  // Client
  //
  //////////////////////////////////////////////////////////////////////////////

  type ClientCreator<TEndpoints extends Endpoints> = (
    apiName: string,
    baseUrl: string,
    options?: ClientOptions
  ) => Client<TEndpoints>;

  type ClientOptions = {
    /**
     * Basic request options to supply to `fetch`
     *
     * @see RequestInit
     *
     * @default { credentials: "include", referrerPolicy: "no-referrer" }
     */
    request?: Omit<RequestInit, "body" | "headers" | "method">;
    adapter?: ResponseAdapter;
    shouldThrow?: boolean;
  };

  type ClientMethod<
    TMethod extends RequestMethod,
    TEndpoints extends Endpoints
  > = <
    TEndpoint extends EndpointUrl<TEndpoints>,
    TOptions extends EndpointRequestOptions<TEndpoints, TEndpoint, TMethod>,
    TSuccesfull extends Koine.Api.DataSuccesfull = Koine.Api.EndpointResponseSuccesfull<
      TEndpoints,
      TEndpoint,
      TMethod
    >,
    TFailed extends Koine.Api.DataFailed = Koine.Api.EndpointResponseFailed<
      TEndpoints,
      TEndpoint,
      TMethod
    >
  >(
    endpoint: TEndpoint,
    options?: TOptions
    // ) => Promise<EndpointResponse<TEndpoints, TEndpoint, TMethod>>;
  ) => Promise<Response<TSuccesfull, TFailed>>;

  /**
   * The `api` interface generated by `createApi`
   */
  type Client<TEndpoints extends Endpoints> = {
    [TMethod in RequestMethod]: ClientMethod<TMethod, TEndpoints>;
  };

  //////////////////////////////////////////////////////////////////////////////
  //
  // Endpoints
  //
  //////////////////////////////////////////////////////////////////////////////

  type EndpointRequestOptions<
    TEndpoints extends Endpoints,
    TEndpoint extends EndpointUrl<TEndpoints>,
    TMethod extends RequestMethod
  > = RequestOptions<
    TMethod,
    TEndpoints[TEndpoint][Uppercase<TMethod>]["request"],
    TEndpoints[TEndpoint][Uppercase<TMethod>]["params"]
  >;

  type EndpointResponseSuccesfull<
    TEndpoints extends Endpoints,
    TEndpoint extends EndpointUrl<TEndpoints>,
    TMethod extends RequestMethod
  > = TEndpoints[TEndpoint][Uppercase<TMethod>]["response"];

  type EndpointResponseFailed<
    TEndpoints extends Endpoints,
    TEndpoint extends EndpointUrl<TEndpoints>,
    TMethod extends RequestMethod
  > = TEndpoints[TEndpoint][Uppercase<TMethod>]["error"];

  type EndpointResponse<
    TEndpoints extends Endpoints,
    TEndpoint extends EndpointUrl<TEndpoints>,
    TMethod extends RequestMethod
  > = Response<
    EndpointResponseSuccesfull<TEndpoints, TEndpoint, TMethod>,
    EndpointResponseFailed<TEndpoints, TEndpoint, TMethod>
  >;

  //////////////////////////////////////////////////////////////////////////////
  //
  // Defintions
  //
  //////////////////////////////////////////////////////////////////////////////

  /**
   * Validate the `Endpoints` definition against the `Endpoint` shape defined
   * here.
   *
   * FIXME: this does not work yet...constraining the API endpoints definitions
   *
   * @see https://github.com/sindresorhus/type-fest/blob/main/source/exact.d.ts
   * @see https://fettblog.eu/typescript-match-the-exact-object-shape/
   * @see https://stackoverflow.com/a/51496652/1938970
   * @see https://github.com/Microsoft/TypeScript/issues/12936
   */
  // type DefineEndpoint<T> =
  //   T extends Endpoint ?
  //   Exclude<keyof T, keyof Endpoint> extends never ?
  //   T : "Endpoint must follow `Koine.Api.Endpoint` shape" : never;
  type DefineEndpoint<T extends EndpointShape> = T;
  type DefineEndpoints<T extends Endpoints> = {};
  type EndpointShape = {
    [TMethod in Uppercase<RequestMethod>]?: DataTypes<TMethod>;
  };

  type Endpoints = Record<string, Endpoint>;
  type Endpoint = {
    [TMethod in Uppercase<RequestMethod>]?: DataTypes<TMethod>;
  };

  type EndpointUrl<TEndpoints extends Endpoints> = Extract<
    keyof TEndpoints,
    string
  >;

  type DataTypes<TMethod extends Uppercase<RequestMethod>> = {
    /**
     * The request body of a non-GET request
     */
    request?: RequestJson;
    /**
     * The JSON response data returned by the request in case of success
     */
    response?: null | unknown;
    /**
     * The parameters to encode in the URL of the request
     */
    params?: RequestParams;
    /**
     * The shape of the error data returned by the request in case of
     * failure
     */
    error?: null | unknown;
  };

  //////////////////////////////////////////////////////////////////////////////
  //
  // Request
  //
  //////////////////////////////////////////////////////////////////////////////

  type RequestJson = undefined | null | Record<string | number, unknown>;

  type RequestParams = undefined | null | Record<string | number, unknown>;

  /**
   * Shared request options (for every request method)
   *
   * Client options can be overriden here at request level.
   */
  type RequestOptionsShared = ClientOptions & {
    /**
     * Headers will be merged with
     * ```
     * { "content-type": "application/json" }
     * ```
     */
    headers?: RequestInit["headers"];
    /**
     * Timeout in `ms`, if `falsy` there is no timeout
     *
     * @default 10000
     */
    timeout?: number | false | null;
    /**
     * Basic request options to supply to `fetch`
     *
     * @see RequestInit
     *
     * @default { credentials: "include", referrerPolicy: "no-referrer" }
     */
    request?: Omit<RequestInit, "body" | "headers" | "method">;
  };

  /**
   * Request options
   *
   * Client options can be overriden here at request level.
   */
  type RequestOptions<
    TMethod extends RequestMethod,
    TJson extends Record<string, unknown> = {},
    TParams extends RequestParams = {}
  > = RequestOptionsShared &
    ([TMethod] extends ["get"]
      ? {
          /**
           * JSON request body
           */
          json?: TJson;
          /**
           * Params will be serialized into a string and appended to the URL
           */
          params?: TParams;
        }
      : {
          /**
           * JSON request body
           *
           * @default {}
           */
          json?: TJson;
          /**
           * Params will be serialized into a string and appended to the URL
           */
          params?: TParams;
        });

  type RequestMethod = "get" | "post" | "put" | "patch" | "delete";

  //////////////////////////////////////////////////////////////////////////////
  //
  // Response
  //
  //////////////////////////////////////////////////////////////////////////////

  type DataSuccesfull = unknown;

  type DataFailed = unknown;

  type ResponseShared<
    T extends Record<string, unknown> = Record<string, unknown>
  > = T & {
    status: _Response["status"];
    msg: _Response["statusText"];
  };

  type ResponseSuccesfull<Data extends DataSuccesfull = DataSuccesfull> = {
    status: _Response["status"];
    msg: _Response["statusText"];
    ok: true;
    fail?: false;
    data: Data;
  };

  type ResponseFailed<Data extends DataFailed = DataFailed> = {
    status: _Response["status"];
    msg: _Response["statusText"];
    ok?: false;
    fail: true;
    data: Data;
  };

  type Response<Succesfull extends DataSuccesfull, Failed extends DataFailed> =
    // FIXME: without the type duplication below the following two lines do not
    // work as they do not narrow the type when checking for the boolean values
    // truthiness
    // | ResponseSuccesfull<Succesfull>
    // | ResponseFailed<Succesfull>;
    | {
        status: _Response["status"];
        msg: _Response["statusText"];
        ok: true;
        fail?: false;
        data: Succesfull;
      }
    | {
        status: _Response["status"];
        msg: _Response["statusText"];
        ok?: false;
        fail: true;
        data: Failed;
      };

  type ResponseAdapter = <
    Succesfull extends DataSuccesfull = DataSuccesfull,
    Failed extends DataFailed = DataFailed
  >(
    response: _Response,
    options: TOptions
  ) => Promise<Koine.Api.Response<Succesfull, Failed>>;

  //////////////////////////////////////////////////////////////////////////////
  //
  // Hooks
  //
  //////////////////////////////////////////////////////////////////////////////

  /**
   * Api hooks map for `react`, each request method has its own `use{Method}`
   * hook.
   *
   * These hooks are implemented with different libraries or, in the future as
   * standalone hooks, see SWR ones to start with.
   */
  type HooksMaps = {
    [TMethod in RequestMethod]: `use${Capitalize<TMethod>}`;
  };

  type HooksMapsByName = { [K in keyof HooksMaps as HooksMaps[K]]: K };

  //////////////////////////////////////////////////////////////////////////////
  //
  // Generate shortcuts
  //
  //////////////////////////////////////////////////////////////////////////////

  /**
   * To generate all available helpers use in your `API` types:
   *
   * ```ts
   * type Response = Koine.Api.GenerateResponseHelpers<Endpoints>;
   * type Request = Koine.Api.GenerateRequestHelpers<Endpoints>;
   * type Get = Koine.Api.GenerateGetHelpers<Endpoints>;
   * type Post = Koine.Api.GeneratePostHelpers<Endpoints>;
   * ```
   */
  type Generate = "here just to read the example usage";

  type _ShortcutsMaps = {
    [TMethod in RequestMethod]: Capitalize<TMethod>;
  };

  type _ShortcutsMapsByMethod = {
    [K in keyof _ShortcutsMaps as _ShortcutsMaps[K]]: K;
  };

  /**
   * @example
   * ```ts
   * // define the type on your `API` types:
   * type Response = Koine.Api.GenerateResponseShortcuts<Endpoints>;
   *
   * // consume the type wherever in your app:
   * type MyData = API.Response["get"]["my/endpoint"];
   * ```
   */
  type GenerateResponseShortcuts<TEndpoints extends Endpoints> = {
    [TMethod in RequestMethod]: {
      [TEndpointUrl in keyof TEndpoints]: TEndpoints[TEndpointUrl][Uppercase<TMethod>]["response"];
    };
  };

  /**
   * @example
   * ```ts
   * // define the type on your `API` types:
   * type Get = Koine.Api.GenerateResponseShortcuts<Endpoints>;
   *
   * // consume the type wherever in your app:
   * type MyData = API.Get["my/endpoint"];
   * ```
   */
  type GenerateGetShortcuts<TEndpoints extends Endpoints> = {
    [TEndpointUrl in keyof TEndpoints]: TEndpoints[TEndpointUrl]["GET"]["response"];
  };

  /**
   * @example
   * ```ts
   * // define the type on your `API` types:
   * type Post = Koine.Api.GenerateResponseShortcuts<Endpoints>;
   *
   * // consume the type wherever in your app:
   * type MyData = API.Post["my/endpoint"];
   * ```
   */
  type GeneratePostShortcuts<TEndpoints extends Endpoints> = {
    [TEndpointUrl in keyof TEndpoints]: TEndpoints[TEndpointUrl]["POST"]["response"];
  };

  /**
   * This is not useful as it is the same as doing
   * `API.Endpoints["my/endpoint"]["GET"]["response"];`
   *
   * @example
   * ```ts
   * // define the type on your `API` types:
   * type Response = Koine.Api.GenerateResponseShortcuts<Endpoints>;
   *
   * // consume the type wherever in your app:
   * type MyData = API.$["my/endpoint"]["get"]["response"];
   * ```
   * @deprecated
   */
  // type GenerateAllShortcuts<TEndpoints extends Endpoints> = {
  //   [TEndpointUrl in keyof TEndpoints]: {
  //     [TMethod in RequestMethod]: {
  //       [DataType in EndpointDataType]: TEndpoints[TEndpointUrl][Uppercase<TMethod>][DataType];
  //     }
  //   }
  // }
}
